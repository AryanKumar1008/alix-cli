import shutil
from pathlib import Path
from datetime import datetime
from typing import List, Optional

from alix.shell_detector import ShellDetector, ShellType
from alix.storage import AliasStorage
from alix.models import Alias


class ShellIntegrator:
    """Apply aliases to shell configuration files"""

    ALIX_MARKER_START = "# === ALIX MANAGED ALIASES START ==="
    ALIX_MARKER_END = "# === ALIX MANAGED ALIASES END ==="

    def __init__(self):
        self.detector = ShellDetector()
        self.storage = AliasStorage()
        self.shell_type = self.detector.detect_current_shell()

    def get_target_file(self) -> Optional[Path]:
        """Get the appropriate shell config file to modify"""
        configs = self.detector.find_config_files(self.shell_type)

        # Priority order for different shells
        priority_files = {
            ShellType.BASH: [".bash_aliases", ".bashrc", ".bash_profile"],
            ShellType.ZSH: [".zsh_aliases", ".zshrc"],
            ShellType.FISH: [".config/fish/config.fish"],
        }

        shell_priorities = priority_files.get(self.shell_type, [])

        for priority in shell_priorities:
            if priority in configs:
                return configs[priority]

        # Return first available if no priority match
        return next(iter(configs.values())) if configs else None

    def backup_shell_config(self, config_file: Path) -> Path:
        """Create backup of shell configuration file"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_path = config_file.parent / f"{config_file.name}.alix_backup_{timestamp}"
        shutil.copy2(config_file, backup_path)
        return backup_path

    def export_aliases(self, shell_type: ShellType) -> str:
        """Export aliases in shell-specific format"""
        aliases = self.storage.list_all()

        if shell_type == ShellType.FISH:
            lines = [f"alias {a.name}='{a.command}'" for a in aliases]
        else:  # Bash, Zsh, Sh
            lines = [f"alias {a.name}='{a.command}'" for a in aliases]

        return "\n".join(lines)

    def apply_aliases(self, target_file: Optional[Path] = None) -> tuple[bool, str]:
        """Apply aliases to shell configuration file"""
        if not target_file:
            target_file = self.get_target_file()

        if not target_file:
            return False, "No shell configuration file found"

        # Create backup
        backup_path = self.backup_shell_config(target_file)

        # Read current config
        content = target_file.read_text()

        # Remove old alix section if exists
        start_idx = content.find(self.ALIX_MARKER_START)
        end_idx = content.find(self.ALIX_MARKER_END)

        if start_idx != -1 and end_idx != -1:
            content = content[:start_idx] + content[end_idx + len(self.ALIX_MARKER_END) + 1:]

        # Add new aliases section
        aliases_section = f"\n{self.ALIX_MARKER_START}\n"
        aliases_section += f"# Generated by alix on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        aliases_section += self.export_aliases(self.shell_type)
        aliases_section += f"\n{self.ALIX_MARKER_END}\n"

        # Append to file
        content = content.rstrip() + aliases_section
        target_file.write_text(content)

        return True, f"Applied {len(self.storage.list_all())} aliases to {target_file.name}"