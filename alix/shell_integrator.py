import shutil
from pathlib import Path
from datetime import datetime
from typing import Optional

from alix.shell_detector import ShellDetector, ShellType
from alix.storage import AliasStorage
from alix.models import Alias, TEST_ALIAS_NAME


class ShellIntegrator:
    """Apply aliases to shell configuration files"""

    ALIX_MARKER_START = "# === ALIX MANAGED ALIASES START ==="
    ALIX_MARKER_END = "# === ALIX MANAGED ALIASES END ==="

    def __init__(self):
        self.detector = ShellDetector()
        self.storage = AliasStorage()
        self.shell_type = self.detector.detect_current_shell()

    def get_target_file(self) -> Optional[Path]:
        """Get the appropriate shell config file to modify"""
        configs = self.detector.find_config_files(self.shell_type)

        # Priority order for different shells
        priority_files = {
            ShellType.BASH: [".bash_aliases", ".bashrc", ".bash_profile"],
            ShellType.ZSH: [".zsh_aliases", ".zshrc"],
            ShellType.FISH: [".config/fish/config.fish"],
        }

        shell_priorities = priority_files.get(self.shell_type, [])

        for priority in shell_priorities:
            if priority in configs:
                return configs[priority]

        # Return first available if no priority match
        return next(iter(configs.values())) if configs else None

    def backup_shell_config(self, config_file: Path) -> Path:
        """Create backup of shell configuration file"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_path = config_file.parent / f"{config_file.name}.alix_backup_{timestamp}"
        shutil.copy2(config_file, backup_path)
        return backup_path

    def export_aliases(self, shell_type: ShellType) -> str:
        """Export aliases in shell-specific format"""
        aliases = self.storage.list_all()

        if shell_type == ShellType.FISH:
            lines = [f"alias {a.name}='{a.command}'" for a in aliases]
        else:  # Bash, Zsh, Sh
            lines = [f"alias {a.name}='{a.command}'" for a in aliases]

        return "\n".join(lines)

    def apply_aliases(self, target_file: Optional[Path] = None) -> tuple[bool, str]:
        """Apply aliases to shell configuration file"""
        if not target_file:
            target_file = self.get_target_file()

        if not target_file:
            return False, "No shell configuration file found"

        # Create backup
        backup_path = self.backup_shell_config(target_file)

        # Read current config
        content = target_file.read_text()

        # Remove old alix section if exists
        start_idx = content.find(self.ALIX_MARKER_START)
        end_idx = content.find(self.ALIX_MARKER_END)

        if start_idx != -1 and end_idx != -1:
            content = content[:start_idx] + content[end_idx + len(self.ALIX_MARKER_END) + 1:]

        # Add new aliases section
        aliases_section = f"\n{self.ALIX_MARKER_START}\n"
        aliases_section += f"# Generated by alix on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        aliases_section += self.export_aliases(self.shell_type)
        aliases_section += f"\n{self.ALIX_MARKER_END}\n"

        # Append to file
        content = content.rstrip() + aliases_section
        target_file.write_text(content)

        return True, f"Applied {len(self.storage.list_all())} aliases to {target_file.name}"

    # NEW METHOD: apply_single_alias
    def apply_single_alias(self, alias: Alias, auto_reload: bool = True) -> tuple[bool, str]:
        """Apply a single alias immediately to the current shell session"""
        target_file = self.get_target_file()

        if not target_file:
            return False, "No shell configuration file found"

        # Read current config
        content = target_file.read_text()

        # Check if alix section exists
        start_idx = content.find(self.ALIX_MARKER_START)
        end_idx = content.find(self.ALIX_MARKER_END)

        alias_line = f"alias {alias.name}='{alias.command}'"

        if start_idx != -1 and end_idx != -1:
            # Insert into existing alix section
            section_content = content[start_idx:end_idx]
            if f"alias {alias.name}=" not in section_content:
                # Add before the end marker
                new_content = content[:end_idx] + f"{alias_line}\n" + content[end_idx:]
                target_file.write_text(new_content)
        else:
            # Create new alix section
            aliases_section = f"\n{self.ALIX_MARKER_START}\n"
            aliases_section += f"# Generated by alix on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
            aliases_section += f"{alias_line}\n"
            aliases_section += f"{self.ALIX_MARKER_END}\n"

            content = content.rstrip() + aliases_section
            target_file.write_text(content)

        if auto_reload:
            self.reload_shell_config()

        return True, f"Applied alias '{alias.name}' to {target_file.name}"

    # NEW METHOD: reload_shell_config
    def reload_shell_config(self) -> bool:
        """Attempt to reload shell configuration"""
        import subprocess
        import os

        target_file = self.get_target_file()
        if not target_file:
            return False

        # Write a temporary script to source the config
        temp_script = f"""
#!/bin/bash
source {target_file}
alias {TEST_ALIAS_NAME} 2>/dev/null || true
"""

        try:
            # For the current Python process environment
            result = subprocess.run(
                ["bash", "-c", f"source {target_file}"],
                capture_output=True,
                text=True
            )
            return result.returncode == 0
        except Exception:
            return False